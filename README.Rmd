---
bibliography: "`r rbbt::bbt_write_bib('data-raw/gilchrist-package.bib', translator='bibtex', overwrite = TRUE)`"
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# gilchrist <a href='https://dmi3kno.github.io/gilchrist'><img src='man/figures/logo.png' align="right" height="200" /></a>

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
<!-- badges: end -->

This package is made to honor the legacy and memory of Warren G. Gilchrist (1932-2015)^[See @davies2016WarrenGilchrist19322015 for a short biography of this truly remarkable individual].

The goal of `{gilchrist}` is to implement Gilchrist QF transformation rules [@gilchrist2000StatisticalModellingQuantile] in R in the form of pipeable function factories.

## Installation

You can install the development version of gilchrist like so:

``` r
remotes::install_packages("dmi3kno/gilchrist")
```
## Gilchrist's QF transformation rules

@gilchrist2000StatisticalModellingQuantile list the following rules for creating new quantile functions out of existing ones.

| Original QF  | Rule          | Resulting QF | Resulting variable |
| ------------ | ------------- | ------------ | ------------------ |
| $Q_Y(u)$     | Relection rule| $-Q(1-u)$ | QF of $-Y$ | 
| $Q_Y(u)$ | Reciprocal rule  | $1/Q(1-u)$ | QF of $1/Y$ |
| $Q_1(u),Q_2(u)$ | Addition rule  | $Q_1(u)+Q_2(u)$ | Valid QF |
| $Q_1(u),Q_2(u)$ | Linear combination rule  | $aQ_1(u)+bQ_2(u)$ | Valid QF for a,b>0 |
| $Q_1(u),Q_2(u)>0$ | Multiplication rule  | $Q_1(u)Q_2(u)$ | Valid QF if $Q_1(u),Q_2(u)>0$ |
| $Q_Y(u)$ | Q-transformation  | $T(Q_Y(u))$ | QF of $T(Y)$, for non-decreasing $T$ |
| $Q_Y(u)$ | p-transformation  | $Q_Y(H(u))$ | p-transformed $Q_Y(u)$, for non-decreasing $H$ |


## Example

This is a basic example which shows you how to solve a common problem:

```{r example}
library(gilchrist)
library(magrittr)
## basic example code
```

In using and testing quantile function it is useful to have an equi-spaced grid of probabilities

```{r}
p_grd <- seq(0,1, by=0.2)
```

### Exponential

Start with standard exponential quantile function

$$S(u)=-\ln(1-u)$$

and add scale parameter. Now our Exponential quantile function looks like in [Wikipedia](https://en.wikipedia.org/wiki/Exponential_distribution).

$$Q(u)=\frac{1}{\lambda}[-\ln(1-u)]$$

In order to remember that our parameter should be reciprocated we call it "ilambda".

```{r logistic}
sqf_exp

qf_exp <- sqf_exp %>% 
  qff_scale(nm_scale="ilambda")
```

We compare our hand-made exponential quantile function to the standard function in R. Note that `qexp` has a reciprocated scale.

```{r}
qf_exp(p_grd, ilambda=10)
# compare to standard exponential quantile function. 
qexp(p_grd, 1/10)
```

### Logistic

Let's do a more challenging example. We will make a logistic distribution in `{gilchrist}`. Logistic distribution consists of exponential $-\ln(1-u)$ and reflected exponential $\ln(u)$ distributions. 

$$Q(u)=\mu+s\ln\left(\frac{u}{1-u}\right)=\mu+s\left[\ln(u)-\ln(1-u)\right]$$
This is how we do it.

```{r}
qf_logistic <- sqf_exp %>% 
  qff_add(
    sqf_exp %>% qff_reflect()
  ) %>% 
  qff_decorate("mu", "s")

qf_logistic(p_grd, mu=4, s=2)
qlogis(p_grd, 4, 2)
```

### Flattened Skew-Logistic

Can we add a little flatness to our newly made logistic distribution and introduce the weights by the exponential components? Lets make Flattened Skew-Logistic Distribution described in @sharma2020QuantileBasedApproachSupervised.

$$Q(u)=\chi+\beta[(1-\delta)\ln(u)-\delta(1-u)+ku]$$

Note that the exponential distribution will gain a weight `delta` and the reflected exponential will gain a weight `1-delta`, because this is the order in which they are listed in `qff_mix`.

```{r}
qf_fsld <- sqf_exp %>% 
  qff_mix(
    qff_reflect(sqf_exp),
    nm_wt="delta") %>% 
  qff_add(qff_scale(sqf_unif,"k")) %>% 
  qff_decorate(nm_location="chi", nm_scale="beta")

qf_fsld(p_grd, delta=0.21, chi=4, beta=2, k=1)
qpd::qfsld(p_grd, bt=2, k=1, dlt=0.21, a=4)
```

### Weibull

Last one for this short tutorial. We make Weibull distribution. Weibull distribution is a Q-transformed  exponential distribution. The transformation function is the the exponent $T(x)=x^k$.

$$Q(u)=\lambda[-\ln(1-u)]^{1/k}$$
Again, to remember that the power should be reciprocated, let's call it "ik".

```{r}
qf_weibull <- sqf_exp %>% 
  qtr_power("ik") %>% 
  qff_scale("lambda")
qf_weibull(p_grd, lambda=2, ik=1/4)
qweibull(p_grd, scale=2,  shape=4)
```

Therefore, you can compose new quantile functions following Gilchrist transformation rules.

## References

