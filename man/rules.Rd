% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rules.R
\name{qtr_reflect}
\alias{qtr_reflect}
\alias{qtr_reciprocate}
\alias{qtr_add}
\alias{qtr_mix}
\alias{qtr_cmix}
\alias{qtr_multiply}
\alias{qtr_shift}
\alias{qtr_scale}
\title{Gilchrist rules}
\usage{
qtr_reflect(fun)

qtr_reciprocate(fun)

qtr_add(fun1, fun2)

qtr_mix(fun1, fun2, nm_wt = ".wt", wt = 0.5, pfn_wt = NULL)

qtr_cmix(fun1, fun2, nm_wt = ".wt", wt = 0.5, pfn_wt = NULL)

qtr_multiply(fun1, fun2)

qtr_shift(fun, nm_shift = ".location", shift = 0, pfn_location = NULL)

qtr_scale(
  fun,
  nm_scale = ".scale",
  scale = 1,
  .invert = FALSE,
  pfn_scale = NULL
)
}
\arguments{
\item{fun, fun1, fun2}{functions}

\item{nm_wt}{character.  The name of the weight parameter (for mixing). The default name is \code{.wt}. The default value is 0.5}

\item{wt}{numeric. Fixed value of weight parameter (for mixing). The default is 0.5.}

\item{pfn_wt}{parameter transforming function.  Default is none.}

\item{nm_shift}{character.  The name of the shift parameter. The default name is \code{.location}. The default value is 0}

\item{shift}{numeric. Fixed value for \code{.location}. The default value is 0}

\item{pfn_location}{parameter transforming function. Default is none.}

\item{nm_scale}{character.  The name of the scale parameter. The default name is \code{.scale}. The default value is 1}

\item{scale}{numeric  Fixed value of the scale parameter. The default value is 1}

\item{.invert}{logical. Should the scale parameter be inverted (1/.scale) before applying. Default FALSE}

\item{pfn_scale}{parameter transforming function. Default is none.}
}
\value{
modified function
}
\description{
Gilchrist rules for constructing valid quantile functions implemented as function factories. All functions take \eqn{Q_1(u)} (the QF of \eqn{X}). Some also take \eqn{Q_2(u)} (the QF of \eqn{Y})
\code{qtr_reflect()}: Reflection rule. Returns \eqn{-Q_1(1-u)} (the QF of \eqn{-X}).
\code{qtr_reciprocate()}: Reciprocal rule. Returns \eqn{1/Q_1(1-u)} (the QF of \eqn{1/X}).
\code{qtr_add()}: Addition rule. Takes \eqn{Q_1(u), Q_2(u)}. Returns \eqn{Q_1(u)+Q_2(u)} - a valid QF of the sum of \eqn{X} and \eqn{Y}.
\code{qtr_mix()}: Linear combination rule with weight parameter \code{.wt}. Takes \eqn{Q_1(u), Q_2(u)}. Returns \eqn{aQ_1(u)+(1-a)Q_2(u)} - a weighted sum QF of \eqn{X} and \eqn{Y}.
\code{qtr_cmix()}: Complimentary linear combination rule with weight parameter \code{.wt}. Takes \eqn{Q_1(u), Q_2(u)}. Returns \eqn{(1-a)Q_1(u)+aQ_2(u)} - a weighted sum QF of \eqn{X} and \eqn{Y}.
\code{qtr_multiply()}:Multiplication rule for positive QFs.  Takes \eqn{Q_1(u), Q_2(u)>0} on all \eqn{[0,1]}. Returns \eqn{Q_1(u)Q_2(u)} - a product QF of \eqn{X} and \eqn{Y}.
\code{qtr_shift()}: Addition rule with a constant shift (adding location parameter). Takes \eqn{Q_1(u)}. Returns \eqn{a+Q_1(u)}.
\code{qtr_scale()}: Multiplication rule with a constant scale (multiplying by the scale parameter). Takes \eqn{Q_1(u)}. Returns \eqn{sQ_1(u)}.
}
\examples{
qf_exp <- function(u)-log(1-u)
qf_logistic <- qtr_add(qf_exp, qtr_reflect(qf_exp))
qf_logistic(0.6)
qlogis(0.6)
}
