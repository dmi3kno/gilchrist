% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qtransformations.R
\name{qtr_lehmann1}
\alias{qtr_lehmann1}
\alias{qtr_reflect_shift}
\alias{qtr_shift_reciprocate}
\alias{qtr_odd}
\alias{qtr_epsilon}
\alias{qtr_shash}
\alias{qtr_exponentiate}
\alias{qtr_fun}
\alias{qtr_qf}
\alias{qtr_oddITL}
\title{Q-transformations}
\usage{
qtr_lehmann1(fun, nm_pow = ".pow", pow = 1, .invert = TRUE)

qtr_reflect_shift(fun)

qtr_shift_reciprocate(fun)

qtr_odd(fun)

qtr_epsilon(fun, nm_pow = ".pow", pow = 1)

qtr_shash(fun, nm_tail = ".dlt", nm_asymm = ".eps", tail = 1, asymm = 0)

qtr_exponentiate(fun, nm_base = ".base", base = exp(1), .invert = FALSE)

qtr_fun(fun, .fun)

qtr_qf(fun, .qf)

qtr_oddITL(fun)
}
\arguments{
\item{fun}{function}

\item{nm_pow}{character.  The name of the power parameter. The default name is \code{.pow}. The default value is 1
Should be a valid unique variable name other than "u"}

\item{pow}{numeric. Fixed value for the power parameter. Default is 1}

\item{.invert}{logical. Should the power parameter be inverted (1/.pow) before applying. Default TRUE}

\item{nm_tail}{character.  The name of the tail thickness parameter. The default name is \code{.dlt}.
The tail thickness parameter should be positive (default value is 1).
Should be a valid unique variable name other than "u"
The asymmetry parameter can be positive or negative (default value is 0).}

\item{nm_asymm}{character.  The name of the asymmetry parameter. The default name is \code{.eps}.
Should be a valid unique variable name other than "u"}

\item{tail}{numeric. Fixed value for the tail parameter. Default is 1}

\item{asymm}{numeric. Default value for}

\item{nm_base}{character. The name of the base parameter.
Should be a valid unique variable name other than "u"}

\item{base}{numeric. Fixed value of the base parameter. The default value is exp(1) (Eulers constant).}

\item{.fun}{function without arguments(or with all default arguments) to be applied as Q-transformation}

\item{.qf}{quantile function made with gilchrist (or regular function wrapped to safely accept optional arguments through ellipsis) to be applied as Q-transformation}
}
\value{
modified function
}
\description{
Some of the typical transformations of QFs, implementing a Q-transformation rule.
\code{qtr_lehmann1()}: Raising of QF to a power using Lehman Type I inverse exponentiation. Returns \eqn{Q_1(u)^{1/k}}.
\code{qtr_exponentiate()}: Exponentiating the QF. Returns \eqn{k^{Q_1(u)}}. Default \eqn{k=e} Euler's constant
\code{qtr_fun()}: Q-transform with generic function without additional arguments. \eqn{.fun(Q_1(u))}.
\code{qtr_epsilon()}: unit-Q-transform using inverse epsilon function \eqn{\frac{(1+Q_1(u))^{1/\beta}-1}{(1+Q_1(u))^{1/\beta}+1}}.
\code{qtr_shash()}: SHASH (sinh-asinh) q-transformation. \eqn{\text{sinh}(1/\delta(Q(u) - \epsilon)}

Note that today p-transformations can be performed by applying Q-transformations to standard uniform distribution
}
\examples{
qf_exp <- function(u)-log(1-u)
qf_weibull <- qtr_lehmann1(qf_exp, "k")
qf_weibull(0.5, k = 1/5)
qweibull(0.5, shape = 5)
qtr_epsilon(qnorm)
qtr_shash(qnorm)
qf_norm <- qtr_decorate(qnorm, nm_location="mu", nm_scale="sigma")
qf_lognorm <- qtr_exponentiate(qf_norm)
qf_lognorm(0.2, mu=2, sigma=0.1)
qlnorm(0.2, 2, 0.1)
qtr_fun(sqf_exp, log1p)
qtr_fun(sqf_exp,log1p)
}
